

## 3.4 new和delete的实现原理
**内置类型**

如果申请的是内置类型的空间，new和malloc，delete和free基本类似，  
不同的地方是：new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时会抛异常，malloc会返回NULL。

**自定义类型**
>**new的原理:**  
>开空间(operator new-->malloc)+构造函数
>1. 调用operator new函数申请空间
>2. 在申请的空间上执行构造函数，完成对象的构造

>**delete的原理:**   
>析构函数+释放空间(operator delete-->free)
>1. 在空间上执行析构函数，完成对象中资源的清理工作
>2. 调用operator delete函数释放对象的空间

![请添加图片描述](https://i-blog.csdnimg.cn/direct/5769fb89618145b280d06c24b111e53e.png)

>**new T[N] 的原理**
>
>1. 调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请
>2. 在申请的空间上执行N次构造函数

>**delete[ ] 的原理**
>
>1. 在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理
>2. 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间

## 3.5 定位new
定位new表达式是在已分配的原始内存空间中**调用构造函数初始化一个对象**。
基本用法
```C++
#include<iostream>
using namespace ::std;
int main()
{
	Date* p2 = (Date *)operator new(sizeof(Date));
	new(p2)Date(1);//如果有默认构造,括号可以不写。
	delete p2;
	return 0;
}
```
>一般我们会在**池化技术**中使用，来提高效率。

# 4.常见问题
## 4.1 malloc/free和new/delete的区别
>malloc/free和new/delete的共同点是：都是从堆上申请空间，并且需要用户手动释放。

>不同的地方是：
>1. malloc和free是函数，  
new和delete是操作符
>2. malloc申请的空间不会初始化，  
new可以初始化
>3. malloc申请空间时，需要手动计算空间大小并传递，  
new只需在其后跟上空间的类型即可，如果是多个对象，[]中指定对象个数即可
>4. malloc的返回值为void*, 在使用时必须强转，  
new不需要，因为new后跟的是空间的类型
>5. malloc申请空间失败时，返回的是NULL，因此使用时必须判空，    
new不需要，但是new需要捕获异常
>6. 申请自定义类型对象时，malloc/free只会开辟空间或销毁空间，不会调用构造函数与析构函数，   
而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理


## 4.2 内存泄漏
内存泄露 memory leak，是指程序在申请内存后，**无法释放已申请的内存空间**，一次内存泄露危害可以忽略，但**内存泄露堆积后果很严重**，无论多少内存,迟早会被占光。
看这样一段代码：
```C++
#include<iostream>
using namespace ::std;
int main()
{
	char* p = new char[1024 * 1024 * 1024];
	return 0;
}
```
这个程序在编译器上会导致内存泄漏吗？
答案是——不会的。因为编译器会在程序结束时，帮你释放这些空间，这就跟手机卡了，关机再重启的道理是一样的，但是如果是一个24*7小时不停的程序呢？比如服务器，如果存在内存泄漏，如果说大了很快就会被检查出来，但是如果一次只泄漏几个字节，那么这台服务器会越用越卡，最终导致服务器宕机——出事故了，那相关人员就得跟着遭殃…

**分类**
1. 系统资源泄漏：
指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。
2. 堆内存泄漏(Heap leak)
堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存，用完后必须通过调用相应的 free或者delete 删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak。

**那该如何解决内存泄漏呢？**

1. 养成良好的编程习惯，对开辟的空间即用即销毁。
2. 合理利用检查内存泄漏的工具，通常这类工具比较昂贵。
3. 利用RAII思想——资源获取即初始化，或者智能指针——充分地体现了RAII思想。
4. 公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。
5. 私有内存管理库，就是公司内部实现的，这套库自带内存检查功能。

>总的来看无非就两类：用良好的习惯，规范，思想，尽可能的减少出错的几率。出了问题用现成的工具去检测问题，及时的改正问题。

资源泄漏：包括但不限于内存泄漏，比如说服务端保存数据，结果服务器有段时间崩了，从而导致客户的数据有所损失，或者在保存数据时，没有及时的读入数据从而导致数据的丢失，等等这都算是资源的泄漏。

